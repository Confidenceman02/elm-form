[{"name":"Form","comment":"\n\n\n## Example\n\nLet's look at a sign-up form example.\n\nWhat to look for:\n\n**The field declarations**\n\nBelow the `Form.form` call you will find all of the form's fields declared with\n\n    |> Form.field ...\n\nThese are the form's field declarations.\n\nThese fields each have individual validations. For example, `|> Field.required ...` means we'll get a validation\nerror if that field is empty (similar for checking the minimum password length). This field definition defines\nsome information that will be used when render the field using [`Form.FieldView`](Form-FieldView) (whether it is a date input, password input, etc.).\n\nThere will be a corresponding parameter in the function we pass in to `Form.form` for every\nfield declaration (in this example, `\\email password passwordConfirmation -> ...`).\n\n**The `combine` validation**\n\nIn addition to the validation errors that individual fields can have independently (like\nrequired fields or minimum password length), we can also do _dependent validations_.\n\nWe use the [`Form.Validation`](Form-Validation) module to take each individual field and combine\nthem into a type and/or errors.\n\n**The `view`**\n\nIn your view you can lay out your fields however you want. While you will be using [`Form.FieldView`](Form-FieldView)\nto render the fields themselves, the rendering for everything besides the fields (including `label`'s, `div`s, etc.) is completely up to you.\n\n    import Form\n    import Form.Field as Field\n    import Form.FieldView as FieldView\n    import Form.Validation as Validation\n    import Html exposing (Html)\n    import Html.Attributes as Attr\n    import Route\n    import Server.Request as Request\n    import Server.Response exposing (Response)\n\n    type alias SignupForm =\n        { email : String\n        , password : String\n        }\n\n    signupForm : Form.HtmlForm String SignupForm () Msg\n    signupForm =\n        Form.form\n            (\\email password passwordConfirmation ->\n                { combine =\n                    Validation.succeed SignupForm\n                        |> Validation.andMap email\n                        |> Validation.andMap\n                            (Validation.map2\n                                (\\passwordValue confirmationValue ->\n                                    if passwordValue == confirmationValue then\n                                        Validation.succeed passwordValue\n\n                                    else\n                                        passwordConfirmation\n                                            |> Validation.fail\n                                                \"Must match password\"\n                                )\n                                password\n                                passwordConfirmation\n                                |> Validation.andThen identity\n                            )\n                , view =\n                    \\info ->\n                        [ Html.label []\n                            [ fieldView info \"Email\" email\n                            , fieldView info \"Password\" password\n                            , fieldView info \"Confirm Password\" passwordConfirmation\n                            ]\n                        , Html.button []\n                            [ if info.submitting then\n                                Html.text \"Signing Up...\"\n\n                              else\n                                Html.text \"Sign Up\"\n                            ]\n                        ]\n                }\n            )\n            |> Form.field \"email\"\n                (Field.text\n                    |> Field.required \"Required\"\n                )\n            |> Form.field \"password\"\n                passwordField\n            |> Form.field \"passwordConfirmation\"\n                passwordField\n\n    passwordField =\n        Field.text\n            |> Field.password\n            |> Field.required \"Required\"\n            |> Field.withClientValidation\n                (\\password ->\n                    ( Just password\n                    , if String.length password < 4 then\n                        [ \"Must be at least 4 characters\" ]\n\n                      else\n                        []\n                    )\n                )\n\n    fieldView :\n        Form.Context String input\n        -> String\n        -> Validation.Field String parsed FieldView.Input\n        -> Html msg\n    fieldView formState label field =\n        Html.div []\n            [ Html.label []\n                [ Html.text (label ++ \" \")\n                , field |> Form.FieldView.input []\n                ]\n            , (if formState.submitAttempted then\n                formState.errors\n                    |> Form.errorsForField field\n                    |> List.map\n                        (\\error ->\n                            Html.li [] [ Html.text error ]\n                        )\n\n               else\n                []\n              )\n                |> Html.ul [ Attr.style \"color\" \"red\" ]\n            ]\n\n\n## Building a Form Parser\n\n@docs Form, HtmlForm, StyledHtmlForm\n\n@docs form\n\n\n### Adding Fields\n\n@docs field\n\n\n## View Functions\n\n@docs Context\n\n\n## Showing Errors\n\n@docs Errors, errorsForField\n\n\n## Rendering Forms\n\n@docs renderHtml, renderStyledHtml\n\n@docs Options, options\n\n@docs withInput, withAction, withOnSubmit, withServerResponse\n\n@docs withGetMethod\n\n@docs Method, methodToString\n\n\n## Running Parsers\n\n@docs parse\n\n\n## Progressively Enhanced Form Techniques (elm-pages)\n\n\n### Hidden Fields\n\nHidden fields are a useful technique when you are progressively enhancing form submissions and sending the key-value form data directly.\nIn `elm-pages` apps this is used often and is an idiomatic approach. If you are wiring up your own `onSubmit` with a Msg\nand never submit the forms directly, then you will likely include additional context as part of your `Msg` instead of\nthrough hidden fields.\n\n@docs hiddenField, hiddenKind\n\n\n## Dynamic Fields\n\n@docs dynamic\n\n\n## Wiring\n\n`elm-form` manages the client-side state of fields, including FieldStatus which you can use to determine when\nin the user's workflow to show validation errors.\n\n@docs Msg, Model, init, update\n\n@docs FormState, FieldState\n\n@docs Validated\n\n@docs ServerResponse\n\n@docs mapMsg, toResult\n\n","unions":[{"name":"Errors","comment":" ","args":["error"],"cases":[]},{"name":"Method","comment":" ","args":[],"cases":[["Get",[]],["Post",[]]]},{"name":"Validated","comment":" ","args":["error","value"],"cases":[["Valid",["value"]],["Invalid",["Maybe.Maybe value","Dict.Dict String.String (List.List error)"]]]}],"aliases":[{"name":"Context","comment":" The data available as the first parameter in a Form's `view` function.\n","args":["error","input"],"type":"{ errors : Form.Errors error, submitting : Basics.Bool, submitAttempted : Basics.Bool, input : input }"},{"name":"FieldState","comment":" ","args":[],"type":"{ value : String.String, status : Form.Validation.FieldStatus }"},{"name":"Form","comment":" A `Form` definition represents\n\n  - The fields of the form\n  - How to render a form's fields into a `view`, and\n  - How to `combine` the fields into a parsed value\n\nA `Form` can be used to:\n\n\n### Render Form\n\n  - Render a `<form>` tag (using [`renderHtml`](#renderHtml) or [`renderStyledHtml`](#renderStyledHtml))\n\n\n### Parse Form\n\n  - [`parse`](#parse) into a [`Validated`](#Validated) value\n  - You can attempt to parse one of multiple `Form` definitions using [`Form.Handler`](Form-Handler).\n\nWhile you almost always will want to render your `Form` in your `view` function, you may also want to parse your form in a few more advanced use cases.\n\nIn a full-stack Elm application, you can try parsing with your Form definition since you can use code sharing to share the same `Form` definition between your frontend and backend.\n`elm-pages` has several built-in functions to help with this.\n\nYou may also want to parse your form data in your frontend to take in-flight form submissions and parse them into your parsed values.\n\n","args":["error","combineAndView","parsed","input"],"type":"Internal.Form.Form error combineAndView parsed input"},{"name":"FormState","comment":" ","args":[],"type":"{ fields : Dict.Dict String.String Form.FieldState, submitAttempted : Basics.Bool }"},{"name":"HtmlForm","comment":" A `Form` that renders to `elm/html`. Can be rendered with [`renderHtml`](#renderHtml).\n","args":["error","parsed","input","msg"],"type":"Form.Form error { combine : Form.Validation.Combined error parsed, view : Form.Context error input -> List.List (Html.Html msg) } parsed input"},{"name":"Model","comment":" The state for all forms. This is a single value that can be used to manage your form state, so when you render your\n`Form`s you will get client-side validations based on the state managed through this value. The state that is\nincluded here for each Form is:\n\n  - Whether submit has been attempted on the form\n  - The current value of each field in the form\n  - The current [`Form.Validation.FieldStatus`](Form-Validation#FieldStatus) for each field in the form\n\nSince this manages the state of multiple Forms, you can even maintain this in your application-wide `Model` rather than\nin a page-specific `Model`. In an `elm-pages` application, this is managed through the framework, but you can achieve\na similar wiring by managing the `Form.Model` globally.\n\nIn more advanced cases, you can manually modify the state of a form. However, it's often enough to just let this package\nmanage the state for you through the [`Form.update`](Form#update) function. Since this is a `Dict String FormState`, you can use `Dict` operations to clear or update\nthe state of forms if you need to manually manage form state.\n\n","args":[],"type":"Dict.Dict String.String Form.FormState"},{"name":"Msg","comment":" ","args":["msg"],"type":"Internal.FieldEvent.Msg msg"},{"name":"Options","comment":" ","args":["error","parsed","input","msg"],"type":"{ id : String.String, action : Maybe.Maybe String.String, method : Form.Method, input : input, onSubmit : Maybe.Maybe ({ fields : List.List ( String.String, String.String ), method : Form.Method, action : String.String, parsed : Form.Validated error parsed } -> msg), serverResponse : Maybe.Maybe (Form.ServerResponse error) }"},{"name":"ServerResponse","comment":" The `persisted` state will be ignored if the client already has a form state. It is useful for persisting state between page loads. For example, `elm-pages` server-rendered routes\nuse this `persisted` state in order to show client-side validations and preserve form field state when a submission is done with JavaScript disabled in the user's browser.\n\n`serverSideErrors` will show on the client-side error state until the form is re-submitted. For example, if you need to check that a username is unique, you can do so by including\nan error in `serverSideErrors` in the response back from the server. The client-side form will show the error until the user changes the username and re-submits the form, allowing the\nserver to re-validate that input.\n\n","args":["error"],"type":"{ persisted : { fields : Maybe.Maybe (List.List ( String.String, String.String )), clientSideErrors : Maybe.Maybe (Dict.Dict String.String (List.List error)) }, serverSideErrors : Dict.Dict String.String (List.List error) }"},{"name":"StyledHtmlForm","comment":" A `Form` that renders to [`rtfeldman/elm-css`](https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/). Can be rendered with [`renderStyledHtml`](#renderStyledHtml).\n","args":["error","parsed","input","msg"],"type":"Form.Form error { combine : Form.Validation.Combined error parsed, view : Form.Context error input -> List.List (Html.Styled.Html msg) } parsed input"}],"values":[{"name":"dynamic","comment":" ","type":"(decider -> Form.Form error { combine : Form.Validation.Validation error parsed named constraints1, view : subView } parsed input) -> Form.Form error ({ combine : decider -> Form.Validation.Validation error parsed named constraints1, view : decider -> subView } -> combineAndView) parsed input -> Form.Form error combineAndView parsed input"},{"name":"errorsForField","comment":" ","type":"Form.Validation.Field error parsed kind -> Form.Errors error -> List.List error"},{"name":"field","comment":" Declare a visible field for the form.\n\nUse [`Form.Field`](Form-Field) to define the field and its validations.\n\n    form =\n        Form.form\n            (\\email ->\n                { combine =\n                    Validation.succeed SignupForm\n                        |> Validation.andMap email\n                , view = \\info -> [{- render fields -}]\n                }\n            )\n            |> Form.field \"email\"\n                (Field.text |> Field.required \"Required\")\n\n","type":"String.String -> Form.Field.Field error parsed input initial kind constraints -> Form.Form error (Form.Validation.Field error parsed kind -> combineAndView) parsedCombined input -> Form.Form error combineAndView parsedCombined input"},{"name":"form","comment":" Initialize the builder for a `Form`. Typically an anonymous function is passed in to this function, with one\nparameter for each field that comes after.\n\n    form =\n        Form.form\n            (\\name email ->\n                { combine =\n                    Validation.succeed User\n                        |> Validation.andMap name\n                        |> Validation.andMap email\n                , view = \\info -> [{- render fields -}]\n                }\n            )\n            |> Form.field \"name\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"email\" (Field.text |> Field.required \"Required\")\n\n","type":"combineAndView -> Form.Form String.String combineAndView parsed input"},{"name":"hiddenField","comment":" Declare a hidden field for the form.\n\nUnlike [`field`](#field) declarations which are rendered using [`Form.FieldView`](Form-FieldView)\nfunctions, `hiddenField` inputs are automatically inserted into the form when you render it.\n\nYou define the field's validations the same way as for `field`, with the\n[`Form.Field`](Form-Field) API.\n\n    form =\n        Form.form\n            (\\quantity productId ->\n                { combine = {- combine fields -}\n                , view = \\info -> [{- render visible fields -}]\n                }\n            )\n            |> Form.field \"quantity\"\n                (Field.int |> Field.required \"Required\")\n            |> Form.field \"productId\"\n                (Field.text\n                    |> Field.required \"Required\"\n                    |> Field.withInitialValue (\\product -> Form.Value.string product.id)\n                )\n\n","type":"String.String -> Form.Field.Field error parsed input initial kind constraints -> Form.Form error (Form.Validation.Field error parsed Form.FieldView.Hidden -> combineAndView) parsedCombined input -> Form.Form error combineAndView parsedCombined input"},{"name":"hiddenKind","comment":" ","type":"( String.String, String.String ) -> error -> Form.Form error combineAndView parsed input -> Form.Form error combineAndView parsed input"},{"name":"init","comment":" Initialize the [`Form.Model`](Form#Model).\n\n    import Form\n\n    init : Flags -> ( Model, Cmd Msg )\n    init flags =\n        ( { formModel = Form.init\n          , submitting = False\n          }\n        , Cmd.none\n        )\n\n","type":"Form.Model"},{"name":"mapMsg","comment":" ","type":"(msg -> msgMapped) -> Form.Msg msg -> Form.Msg msgMapped"},{"name":"methodToString","comment":" ","type":"Form.Method -> String.String"},{"name":"options","comment":" Initialize a set of default options with a unique `id` for your Form. Note that even if you are rendering the same form\nmultiple times this ID needs to be unique in order to manage the state of each form independently.\n\nFor example,\n\n    cartView model items =\n        items\n            |> List.map\n                (\\item ->\n                    itemForm\n                        |> Form.renderHtml\n                            { submitting = model.submitting\n                            , state = model.formState\n                            , toMsg = FormMsg\n                            }\n                            (Form.options (\"cart-item-\" ++ item.id))\n                            []\n                )\n            |> Html.div []\n\n","type":"String.String -> Form.Options error parsed () msg"},{"name":"parse","comment":" ","type":"String.String -> Form.Model -> input -> Form.Form error { info | combine : Form.Validation.Validation error parsed named constraints } parsed input -> Form.Validated error parsed"},{"name":"renderHtml","comment":" Render the form to `elm/html`.\n\n    view model =\n        signUpForm\n            |> Form.renderHtml\n                { submitting = model.submitting\n                , state = model.formState\n                , toMsg = FormMsg\n                }\n                (Form.options \"signUpForm\")\n                []\n\nNote: In `elm-pages`, you'll want to use the `Pages.Form.renderHtml` function instead.\n\n","type":"{ submitting : Basics.Bool, state : Form.Model, toMsg : Form.Msg mappedMsg -> mappedMsg } -> Form.Options error parsed input mappedMsg -> List.List (Html.Attribute mappedMsg) -> Form.Form error { combine : Form.Validation.Validation error parsed named constraints, view : Form.Context error input -> List.List (Html.Html mappedMsg) } parsed input -> Html.Html mappedMsg"},{"name":"renderStyledHtml","comment":" Render the form to [`rtfeldman/elm-css`](https://package.elm-lang.org/packages/rtfeldman/elm-css/latest/).\n\n    view model =\n        signUpForm\n            |> Form.renderStyledHtml\n                { submitting = model.submitting\n                , state = model.formState\n                , toMsg = FormMsg\n                }\n                (Form.options \"signUpForm\")\n                []\n\nNote: In `elm-pages`, you'll want to use the `Pages.Form.renderStyledHtml` function instead.\n\n","type":"{ submitting : Basics.Bool, state : Form.Model, toMsg : Form.Msg mappedMsg -> mappedMsg } -> Form.Options error parsed input mappedMsg -> List.List (Html.Styled.Attribute mappedMsg) -> Form.Form error { combine : Form.Validation.Validation error parsed field constraints, view : Form.Context error input -> List.List (Html.Styled.Html mappedMsg) } parsed input -> Html.Styled.Html mappedMsg"},{"name":"toResult","comment":" Parsing a `Form` gives you a [`Validated`](#Validated) type. This helper turns it into a `Result`\nthat is semantically the same. This can be useful for using a parsed `Form` value in a pipeline.\n","type":"Form.Validated error value -> Result.Result ( Maybe.Maybe value, Dict.Dict String.String (List.List error) ) value"},{"name":"update","comment":" ","type":"Form.Msg msg -> Form.Model -> ( Form.Model, Platform.Cmd.Cmd msg )"},{"name":"withAction","comment":" Set the `action` attribute of the rendered `<form>` element. Note that the `action` attribute in the `withOnSubmit` is preprocessed in the browser, so the String will point to the same URL but\nwon't necessarily be the exact same String that was passed in. For example, if you set `options |> Form.withAction \"/login\"`, your onSubmit will receive an absolute URL such as `{ action = \"https://mysite.com/login\" {- , ... -} }`.\n\nSetting the `action` can be useful if you are progressively enhancing form behavior. The default browser form submission behavior is to submit to the current URL if no `action` attribute is set, and an `action` is present\nthen the form submission will go to the given URL. If you are attempting to use progressive enhancement then you can simulate this behavior through your `withOnSubmit` handler, or you may be using a framework that has this simulation built in like `elm-pages`.\n\nSee also <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#action>.\n\n","type":"String.String -> Form.Options error parsed input msg -> Form.Options error parsed input msg"},{"name":"withGetMethod","comment":" The default Method from `options` is `Post` since that is the most common. The `Get` Method for form submissions will add the form fields as a query string and navigate to that route using a GET.\nYou will need to progressively enhance your onSubmit to simulate this browser behavior if you want something similar, or use a framework that has this simulation built in like `elm-pages`.\n","type":"Form.Options error parsed input msg -> Form.Options error parsed input msg"},{"name":"withInput","comment":" You can pass in an `input` value to the `Options` that are passed in to [`renderHtml`](#renderHtml) or [`renderStyledHtml`](#renderStyledHtml).\n\nYou can use whichever data type you want as your `input` value. You will then have access to that value in two places:\n\n1.  The Form's `view` through the [`Context`](#Context) argument's `input` field.\n2.  [`Form.Field.withInitialValue`](Form-Field#withInitialValue)\n\nOne example where you would use an `input` value is if you have an existing UserProfile from the server that you want to use to pre-populate the form fields.\n\n    import Form\n    import Form.Field as Field\n    import Form.Validation as Validation\n\n    type alias UserProfile =\n        { name : String\n        , email : String\n        }\n\n    userProfileForm : Form.HtmlForm String UserProfile UserProfile msg\n    userProfileForm =\n        (\\name email ->\n            { combine =\n                Validation.succeed UserProfile\n                    |> Validation.andMap name\n                    |> Validation.andMap email\n            , view =\n                \\context ->\n                    [ Html.h2\n                        []\n                        [ Html.text\n                            --  use the input to display Model data\n                            (context.input\n                                ++ \"'s Profile\"\n                            )\n                        ]\n                    , fieldView \"Name\" name\n                    , fieldView \"Email\" email\n                    , if context.submitting then\n                        Html.button [ Html.Attributes.disabled True ] [ Html.text \"Updating...\" ]\n\n                      else\n                        Html.button [] [ Html.text \"Update\" ]\n                    ]\n            }\n        )\n            |> Form.form\n            |> Form.field \"name\"\n                (Field.text\n                    |> Field.required \"Required\"\n                    |> Field.withInitialValue .name\n                )\n            |> Form.field \"email\"\n                (Field.text\n                    |> Field.required \"Required\"\n                    |> Field.withInitialValue .email\n                )\n\n    view model =\n        [ model.userProfile\n            |> Maybe.map\n                (\\userProfile ->\n                    userProfileForm\n                        |> Form.renderHtml\n                            { submitting = model.submitting\n                            , state = model.formState\n                            , toMsg = FormMsg\n                            }\n                            (Form.options \"userProfile\"\n                                |> Form.withInput userProfile\n                            )\n                            []\n                )\n            |> Maybe.withDefault \"Loading Profile...\"\n        ]\n\n","type":"input -> Form.Options error parsed () msg -> Form.Options error parsed input msg"},{"name":"withOnSubmit","comment":" You can add an onSubmit handler to the Form's `Options`. If you are using a framework that is integrated with `elm-form` (such as `elm-pages`), then you can\nrely on the framework's onSubmit behavior. Otherwise, you will need to do something with the form when there is a valid form submission.\n\nThere are a few different approaches you can use.\n\n1.  Progressively enhance the raw FormData submission. Since `withOnSubmit` gives you access to `{ fields : List ( String, String ) {- ... -} }`, you can propagate the raw key-value pairs (`fields`) and send those to your API. If you are doing full-stack Elm with `elm-pages` or Lamdera, then this can be a great fit because you can do code sharing and re-use your `Form` definition on the backend to parse the raw FormData. However, you may not want to use this approach with frontend-only Elm because you may prefer to communicate with your backend using more structured data like JSON rather than FormData (which is just key-value strings).\n2.  Parse into your preferred type, then with an on-submit Msg, check if the data is `Valid`, and if it is, use the parsed data to make a request to your API (by JSON-encoding the value, building a GraphQL request, etc.).\n3.  In your Form's `combine`, directly parse into a representation of your request, such as a `Json.Encode.Value`, a `Cmd Msg`, a `Task error Msg`, or an intermediary data type that represents an API request.\n\nLet's look at an example of approach (3). In this example, we define a `Request` record alias which represents an API request. Note, there is nothing special about this `Request` type, this is just\nan example ot illustrate this general pattern, but consider the best types for your use case when you adapt this example for your app.\n\n    import Form\n    import Form.Field as Field\n    import Form.Validation as Validation\n\n    type alias Request =\n        { path : String\n        , body : Encode.Value\n        , expect : Http.Expect Msg\n        }\n\n    sendRequest : Request -> Cmd Msg\n    sendRequest request =\n        Http.post\n            { url = \"https://myservice.com/api\" ++ request.path\n            , body = Http.jsonBody request.body\n            , expect = request.expect\n            }\n\n    userProfileForm : Form.HtmlForm String Request input msg\n    userProfileForm =\n        (\\name email ->\n            { combine =\n                Validation.succeed\n                    (\\nameValue emailValue ->\n                        { path = \"/api/user\"\n                        , body =\n                            Encode.object\n                                [ ( \"name\", Encode.string nameValue )\n                                , ( \"email\", Encode.string emailValue )\n                                ]\n                        }\n                    , expect = Http.expectJson GotUpdatedProfile profileDecoder\n                    )\n                    |> Validation.andMap name\n                    |> Validation.andMap email\n            , view = \\context -> [{- ... view here -}]\n            }\n        )\n            |> Form.form\n            |> Form.field \"name\" (Field.text |> Field.required \"Required\")\n            |> Form.field \"email\" (Field.text |> Field.required \"Required\")\n\n","type":"({ fields : List.List ( String.String, String.String ), method : Form.Method, action : String.String, parsed : Form.Validated error parsed } -> msg) -> Form.Options error parsed input oldMsg -> Form.Options error parsed input msg"},{"name":"withServerResponse","comment":" You can render your `Form` with an initial set of values and errors that semantically represent a server response.\n\nConceptually, this is like sending a traditional form submission to a backend. When this happens in a `<form>` with no\nJavaScript event handlers, the server responds with a new page load, and that newly rendered page needs to contain any\nfield errors and persist any field values that were submitted so the user can continue filling out their form.\n\nIn an `elm-pages` app, you can submit your forms with JavaScript turned off and see this exact behavior, but you need to\nbe sure to wire in a `ServerResponse` so that the form state is persisted in the freshly rendered page.\n\nYou can also use this `ServerResponse` to send down server-side errors, especially if you are using full-stack Elm.\n\n","type":"Maybe.Maybe (Form.ServerResponse error) -> Form.Options error parsed input msg -> Form.Options error parsed input msg"}],"binops":[]},{"name":"Form.Field","comment":"\n\n@docs Field\n\n\n## Base Fields\n\n@docs text, checkbox, int, float\n\n\n## Multiple Choice Fields\n\n@docs select, OutsideRange\n\n\n## Date/Time Fields\n\n@docs date, time, TimeOfDay\n\n\n## Initial Values\n\n@docs withInitialValue, withOptionalInitialValue\n\n\n## Other\n\n@docs exactValue\n\n\n## Field Configuration\n\n@docs required, withClientValidation, map\n\n\n## Text Field Display Options\n\n@docs email, password, search, telephone, url, textarea\n\n\n## Numeric Field Options\n\n@docs range, withMin, withMax\n\n@docs withMinLength, withMaxLength\n\n@docs withStep, withFloatStep\n\n\n## Phantom Options\n\n@docs No, Yes\n\n","unions":[{"name":"No","comment":" ","args":[],"cases":[]},{"name":"OutsideRange","comment":" ","args":[],"cases":[["AboveRange",[]],["BelowRange",[]]]},{"name":"Yes","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Field","comment":" ","args":["error","parsed","input","initial","kind","constraints"],"type":"Internal.Field.Field error parsed input initial kind constraints"},{"name":"TimeOfDay","comment":" ","args":[],"type":"{ hours : Basics.Int, minutes : Basics.Int }"}],"values":[{"name":"checkbox","comment":" ","type":"Form.Field.Field error Basics.Bool input Basics.Bool Form.FieldView.Input { required : () }"},{"name":"date","comment":" ","type":"{ invalid : String.String -> error } -> Form.Field.Field error (Maybe.Maybe Date.Date) input Date.Date Form.FieldView.Input { min : Date.Date, max : Date.Date, required : (), wasMapped : Form.Field.No, step : Basics.Int }"},{"name":"email","comment":" ","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"exactValue","comment":" ","type":"String.String -> error -> Form.Field.Field error String.String input Basics.Never Form.FieldView.Input { required : (), plainText : (), wasMapped : Form.Field.No }"},{"name":"float","comment":" ","type":"{ invalid : String.String -> error } -> Form.Field.Field error (Maybe.Maybe Basics.Float) input Basics.Float Form.FieldView.Input { min : Basics.Float, max : Basics.Float, required : (), wasMapped : Form.Field.No }"},{"name":"int","comment":" ","type":"{ invalid : String.String -> error } -> Form.Field.Field error (Maybe.Maybe Basics.Int) input Basics.Int Form.FieldView.Input { min : Basics.Int, max : Basics.Int, required : (), wasMapped : Form.Field.No, step : Basics.Int }"},{"name":"map","comment":" ","type":"(parsed -> mapped) -> Form.Field.Field error parsed input initial kind constraints -> Form.Field.Field error mapped input initial kind { constraints | wasMapped : Form.Field.Yes }"},{"name":"password","comment":" ","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"range","comment":" ","type":"{ min : numberInitial, max : numberInitial, missing : error, invalid : Form.Field.OutsideRange -> error } -> Form.Field.Field error (Maybe.Maybe valueType) input numberInitial kind { constraints | required : (), min : numberInitial, max : numberInitial, wasMapped : Form.Field.No } -> Form.Field.Field error valueType input numberInitial Form.FieldView.Input { constraints | wasMapped : Form.Field.No }"},{"name":"required","comment":" ","type":"error -> Form.Field.Field error (Maybe.Maybe parsed) kind input initial { constraints | required : (), wasMapped : Form.Field.No } -> Form.Field.Field error parsed kind input initial { constraints | wasMapped : Form.Field.No }"},{"name":"search","comment":" ","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"select","comment":" ","type":"List.List ( String.String, option ) -> (String.String -> error) -> Form.Field.Field error (Maybe.Maybe option) input option (Internal.Input.Options option) { required : (), wasMapped : Form.Field.No }"},{"name":"telephone","comment":" ","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"text","comment":" ","type":"Form.Field.Field error (Maybe.Maybe String.String) input String.String Form.FieldView.Input { required : (), plainText : (), wasMapped : Form.Field.No, minlength : (), maxlength : () }"},{"name":"textarea","comment":" ","type":"{ rows : Maybe.Maybe Basics.Int, cols : Maybe.Maybe Basics.Int } -> Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"time","comment":" <https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/time>\n","type":"{ invalid : String.String -> error } -> Form.Field.Field error (Maybe.Maybe Form.Field.TimeOfDay) input Form.Field.TimeOfDay Form.FieldView.Input { min : Form.Field.TimeOfDay, max : Form.Field.TimeOfDay, required : (), wasMapped : Form.Field.No }"},{"name":"url","comment":" ","type":"Form.Field.Field error parsed input initial Form.FieldView.Input { constraints | plainText : () } -> Form.Field.Field error parsed input initial Form.FieldView.Input constraints"},{"name":"withClientValidation","comment":" ","type":"(parsed -> ( Maybe.Maybe mapped, List.List error )) -> Form.Field.Field error parsed input initial kind constraints -> Form.Field.Field error mapped input initial kind { constraints | wasMapped : Form.Field.Yes }"},{"name":"withFloatStep","comment":" ","type":"Basics.Float -> Form.Field.Field error value input initial view { constraints | step : Basics.Float } -> Form.Field.Field error value input initial view constraints"},{"name":"withInitialValue","comment":" ","type":"(input -> initial) -> Form.Field.Field error value input initial kind constraints -> Form.Field.Field error value input initial kind constraints"},{"name":"withMax","comment":" ","type":"initial -> error -> Form.Field.Field error parsed input initial kind { constraints | max : initial } -> Form.Field.Field error parsed input initial kind constraints"},{"name":"withMaxLength","comment":" ","type":"Basics.Int -> error -> Form.Field.Field error parsed input initial kind { constraints | maxlength : () } -> Form.Field.Field error parsed input initial kind constraints"},{"name":"withMin","comment":" ","type":"initial -> error -> Form.Field.Field error parsed input initial kind { constraints | min : initial } -> Form.Field.Field error parsed input initial kind constraints"},{"name":"withMinLength","comment":" ","type":"Basics.Int -> error -> Form.Field.Field error parsed input initial kind { constraints | minlength : () } -> Form.Field.Field error parsed input initial kind constraints"},{"name":"withOptionalInitialValue","comment":" ","type":"(input -> Maybe.Maybe initial) -> Form.Field.Field error value input initial kind constraints -> Form.Field.Field error value input initial kind constraints"},{"name":"withStep","comment":" ","type":"Basics.Int -> Form.Field.Field error value input initial view { constraints | step : Basics.Int } -> Form.Field.Field error value input initial view constraints"}],"binops":[]},{"name":"Form.FieldView","comment":"\n\n@docs Input, Options, input, radio, Hidden, select, valueButton\n\n\n## Html.Styled Helpers\n\n@docs radioStyled, selectStyled, inputStyled, valueButtonStyled\n\n","unions":[],"aliases":[{"name":"Hidden","comment":" There are no render helpers for hidden fields because the `Form.renderHtml` helper functions automatically render hidden fields for you.\n","args":[],"type":"Internal.Input.Hidden"},{"name":"Input","comment":" ","args":[],"type":"Internal.Input.Input"},{"name":"Options","comment":" ","args":["a"],"type":"Internal.Input.Options a"}],"values":[{"name":"input","comment":" ","type":"List.List (Html.Attribute msg) -> Form.Validation.Field error parsed Form.FieldView.Input -> Html.Html msg"},{"name":"inputStyled","comment":" ","type":"List.List (Html.Styled.Attribute msg) -> Form.Validation.Field error parsed Form.FieldView.Input -> Html.Styled.Html msg"},{"name":"radio","comment":" ","type":"List.List (Html.Attribute msg) -> (parsed -> (List.List (Html.Attribute msg) -> Html.Html msg) -> Html.Html msg) -> Form.Validation.Field error parsed2 (Form.FieldView.Options parsed) -> Html.Html msg"},{"name":"radioStyled","comment":" ","type":"List.List (Html.Styled.Attribute msg) -> (parsed -> (List.List (Html.Styled.Attribute msg) -> Html.Styled.Html msg) -> Html.Styled.Html msg) -> Form.Validation.Field error parsed2 (Form.FieldView.Options parsed) -> Html.Styled.Html msg"},{"name":"select","comment":" ","type":"List.List (Html.Attribute msg) -> (parsed -> ( List.List (Html.Attribute msg), String.String )) -> Form.Validation.Field error parsed2 (Form.FieldView.Options parsed) -> Html.Html msg"},{"name":"selectStyled","comment":" ","type":"List.List (Html.Styled.Attribute msg) -> (parsed -> ( List.List (Html.Styled.Attribute msg), String.String )) -> Form.Validation.Field error parsed2 (Form.FieldView.Options parsed) -> Html.Styled.Html msg"},{"name":"valueButton","comment":" Gives you a submit button that will submit the form with a specific value for the given Field.\n","type":"String.String -> List.List (Html.Attribute msg) -> List.List (Html.Html msg) -> Form.Validation.Field error parsed kind -> Html.Html msg"},{"name":"valueButtonStyled","comment":" Gives you a submit button that will submit the form with a specific value for the given Field.\n","type":"String.String -> List.List (Html.Styled.Attribute msg) -> List.List (Html.Styled.Html msg) -> Form.Validation.Field error parsed kind -> Html.Styled.Html msg"}],"binops":[]},{"name":"Form.Handler","comment":"\n\n@docs Handler\n\n@docs init, with\n\n@docs run\n\n","unions":[{"name":"Handler","comment":" ","args":["error","parsed"],"cases":[]}],"aliases":[],"values":[{"name":"init","comment":" ","type":"(parsed -> combined) -> Internal.Form.Form error { combineAndView | combine : Form.Validation.Validation error parsed kind constraints } parsed input -> Form.Handler.Handler error combined"},{"name":"run","comment":" ","type":"List.List ( String.String, String.String ) -> Form.Handler.Handler error parsed -> Form.Validated error parsed"},{"name":"with","comment":" ","type":"(parsed -> combined) -> Internal.Form.Form error { combineAndView | combine : Form.Validation.Validation error parsed kind constraints } parsed input -> Form.Handler.Handler error combined -> Form.Handler.Handler error combined"}],"binops":[]},{"name":"Form.Validation","comment":"\n\n\n## Validations\n\n@docs Combined, Field, Validation\n\n@docs andMap, andThen, fail, fromMaybe, fromResult, map, map2, parseWithError, succeed, withError, withErrorIf, withFallback\n\n\n## Field Metadata\n\n@docs value, fieldName\n\n@docs FieldStatus, fieldStatus, fieldStatusToString\n\n@docs statusAtLeast\n\n\n## Mapping\n\n@docs map3, map4, map5, map6, map7, map8, map9\n\n@docs mapToCombined\n\n\n## Global Validation\n\n@docs global\n\n","unions":[{"name":"FieldStatus","comment":" ","args":[],"cases":[["NotVisited",[]],["Focused",[]],["Changed",[]],["Blurred",[]]]}],"aliases":[{"name":"Combined","comment":" ","args":["error","parsed"],"type":"Form.Validation.Validation error parsed Basics.Never Basics.Never"},{"name":"Field","comment":" ","args":["error","parsed","kind"],"type":"Form.Validation.Validation error parsed kind { field : kind }"},{"name":"Validation","comment":" ","args":["error","parsed","kind","constraints"],"type":"Pages.Internal.Form.Validation error parsed kind constraints"}],"values":[{"name":"andMap","comment":" ","type":"Form.Validation.Validation error a named1 constraints1 -> Form.Validation.Validation error (a -> b) named2 constraints2 -> Form.Validation.Combined error b"},{"name":"andThen","comment":" ","type":"(parsed -> Form.Validation.Validation error mapped named1 constraints1) -> Form.Validation.Validation error parsed named2 constraints2 -> Form.Validation.Combined error mapped"},{"name":"fail","comment":" ","type":"error -> Form.Validation.Field error parsed1 field -> Form.Validation.Combined error parsed"},{"name":"fieldName","comment":" ","type":"Form.Validation.Field error parsed kind -> String.String"},{"name":"fieldStatus","comment":" ","type":"Form.Validation.Field error parsed kind -> Form.Validation.FieldStatus"},{"name":"fieldStatusToString","comment":" ","type":"Form.Validation.FieldStatus -> String.String"},{"name":"fromMaybe","comment":" ","type":"Maybe.Maybe parsed -> Form.Validation.Combined error parsed"},{"name":"fromResult","comment":" ","type":"Form.Validation.Field error (Result.Result error parsed) kind -> Form.Validation.Combined error parsed"},{"name":"global","comment":" ","type":"Form.Validation.Field error () Basics.Never"},{"name":"map","comment":" ","type":"(parsed -> mapped) -> Form.Validation.Validation error parsed named constraint -> Form.Validation.Validation error mapped named constraint"},{"name":"map2","comment":" ","type":"(a -> b -> c) -> Form.Validation.Validation error a named1 constraints1 -> Form.Validation.Validation error b named2 constraints2 -> Form.Validation.Combined error c"},{"name":"map3","comment":" ","type":"(a1 -> a2 -> a3 -> a4) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Combined error a4"},{"name":"map4","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Combined error a5"},{"name":"map5","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Combined error a6"},{"name":"map6","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 named6 constraints6 -> Form.Validation.Combined error a7"},{"name":"map7","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 named6 constraints6 -> Form.Validation.Validation error a7 named7 constraints7 -> Form.Validation.Combined error a8"},{"name":"map8","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 named6 constraints6 -> Form.Validation.Validation error a7 named7 constraints7 -> Form.Validation.Validation error a8 named8 constraints8 -> Form.Validation.Combined error a9"},{"name":"map9","comment":" ","type":"(a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10) -> Form.Validation.Validation error a1 named1 constraints1 -> Form.Validation.Validation error a2 named2 constraints2 -> Form.Validation.Validation error a3 named3 constraints3 -> Form.Validation.Validation error a4 named4 constraints4 -> Form.Validation.Validation error a5 named5 constraints5 -> Form.Validation.Validation error a6 named6 constraints6 -> Form.Validation.Validation error a7 named7 constraints7 -> Form.Validation.Validation error a8 named8 constraints8 -> Form.Validation.Validation error a9 named9 constraints9 -> Form.Validation.Combined error a10"},{"name":"mapToCombined","comment":" ","type":"(parsed -> mapped) -> Form.Validation.Validation error parsed named constraint -> Form.Validation.Combined error mapped"},{"name":"parseWithError","comment":" ","type":"parsed -> ( String.String, error ) -> Form.Validation.Combined error parsed"},{"name":"statusAtLeast","comment":" ","type":"Form.Validation.FieldStatus -> Form.Validation.Field error parsed kind -> Basics.Bool"},{"name":"succeed","comment":" ","type":"parsed -> Form.Validation.Combined error parsed"},{"name":"value","comment":" ","type":"Form.Validation.Validation error parsed named constraint -> Maybe.Maybe parsed"},{"name":"withError","comment":" ","type":"Form.Validation.Field error parsed1 field -> error -> Form.Validation.Validation error parsed2 named constraints -> Form.Validation.Validation error parsed2 named constraints"},{"name":"withErrorIf","comment":" ","type":"Basics.Bool -> Form.Validation.Field error ignored field -> error -> Form.Validation.Validation error parsed named constraints -> Form.Validation.Validation error parsed named constraints"},{"name":"withFallback","comment":" ","type":"parsed -> Form.Validation.Validation error parsed named constraints -> Form.Validation.Validation error parsed named constraints"}],"binops":[]}]